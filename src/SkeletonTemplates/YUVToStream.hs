module SkeletonTemplates.YUVToStream where

-- temporary hack
actorCodeYUVToStream :: Int -> String
actorCodeYUVToStream uintBitWith =
  unlines
    [ "package std.stdio;"
    , "import std.headers.Parameters.*;"
    , "actor YUVToStream() int(size= " ++
      show uintBitWith ++ ") Y ==> uint(size=8) YUV: "
    , " uint(size=8)  pictureBufferYUV[IM_WIDTH_OUT * IM_HEIGHT_OUT]; "
    , " int (size=16) pictureWidthLuma := IM_WIDTH_OUT;"
    , " int (size=16) pictureHeightLuma := IM_HEIGHT_OUT;  "
    , " int count := 0;"
    , " int write_idx := 0;"
    , " // bool sending := false;"
    , "        int(size=16) twoFiveFive = 255;"
    , "        int(size=16) zero = 0;"
    , "        /***************************************/"
    , "        procedure floor_c(int num)"
    , "        var int i := 0"
    , "        begin"
    , "                while(num >= 0) do "
    , "                        i := i+1;"
    , "                        num := num-1;"
    , "                end"
    , "                Val_UINT8 := clip_i32_u8(i);"
    , "        end"
    , "        uint(size=8) Val_UINT8;"
    , "        /***************************************/"
    , ""
    , "function clip_i32_u8(int(size=32) Value)"
    , "    -->"
    , "   int(size=32)"
    , "  : if Value > 255 then 255 else if Value < 0 then 0 else Value end end"
    , "  end"
    , ""
    , "    "
    , "                 "
    , " getPixValueY: action Y:[Bytes] ==>"
    , " guard count < (pictureWidthLuma * pictureHeightLuma)"
    , " do      // floor_c(if Bytes > 255 then 255 else if Bytes < 0 then 0 else Bytes end end);"
    , "                floor_c(if Bytes > 255 then 255 else if Bytes < 0 then 0 else Bytes end end);"
    , "                pictureBufferYUV[count] := Val_UINT8;"
    , "                // pictureBufferYUV[count] := Bytes;"
    , "                count := count + 1;"
    , " end"
    , ""
    , ""
    , " doneCount: action ==> "
    , " guard count = pictureWidthLuma * pictureHeightLuma"
    , " do"
    , "   write_idx := 0;"
    , " end  "
    , ""
    , " send: action ==> YUV:[v] "
    , " guard "
    , "  write_idx < IM_WIDTH_OUT * IM_HEIGHT_OUT * 3"
    , " var"
    , "  uint(size=8) v"
    , " do"
    , "  v := pictureBufferYUV[write_idx mod (IM_WIDTH_OUT * IM_HEIGHT_OUT)];"
    , "  write_idx := write_idx + 1;"
    , " end"
    , " "
    , " done: action ==>"
    , " guard"
    , "  write_idx = IM_WIDTH_OUT * IM_HEIGHT_OUT * 3"
    , " do"
    , "  write_idx := 0;"
    , "   count := 0; "
    , " end"
    , " "
    , " schedule fsm s0 :"
    , " s0 (getPixValueY) --> s0;"
    , " s0 (doneCount) --> s1;"
    , " s1 (send) --> s1;"
    , " s1 (done) --> s0;"
    , " end"
    , " "
    , "// priority"
    , "//  doneCount > getPixValueY;"
    , "//  send.done > send;"
    , "// end"
    , " "
    , ""
    , "end"
    ]
